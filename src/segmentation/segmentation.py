"""Segment person from RGBD images"""

from typing import List, Optional, Tuple

import numpy as np
import torch
from torchvision.models.detection import (
    MaskRCNN_ResNet50_FPN_V2_Weights,
    maskrcnn_resnet50_fpn_v2,
)


class Segmentation:
    """Segment person using maskrcnn"""

    def __init__(self) -> None:
        self.device = "cuda:0" if torch.cuda.is_available() else "cpu"
        self.weights = MaskRCNN_ResNet50_FPN_V2_Weights.DEFAULT
        self.transforms = self.weights.transforms()
        model = maskrcnn_resnet50_fpn_v2(weights=self.weights, progress=False)
        model = model.to(self.device)
        self.model = model.eval()

    def get_person_masks(
        self,
        rgbs: List[np.ndarray],
        thr: float = 0.5,
    ) -> np.ndarray:
        """Segment person given rgbd images
        Args:
            rgbs: List of rgb images
            thr: threshold for the person mask generated by the segmentation model
        Returns:
            Mask images
        """
        images = [
            self.transforms(torch.from_numpy(img.transpose(2, 0, 1)).to(self.device))
            for img in rgbs
        ]
        with torch.no_grad():
            outputs = self.model(images)
            masks = [
                (dict_["masks"][0].squeeze(0) > thr).cpu().numpy() for dict_ in outputs
            ]
        return np.stack(masks)

    def apply_masks(
        self,
        rgbs: List[np.ndarray],
        masks: np.ndarray,
        depths: Optional[List[np.ndarray]],
    ) -> Tuple[List[np.ndarray], List[Optional[np.ndarray]]]:
        """Apply masks on the images"""
        assert masks.ndim == 3, "Masks should be 3 dimensional"
        if depths:
            assert len(depths) == len(
                rgbs
            ), "Number of rgb and depth images should be same!"

        rgb_p = np.where(np.expand_dims(masks, -1), np.stack(rgbs), 0)
        if depths:
            tmp = np.where(masks, np.stack(depths), 0)
            dep_p = list(np.moveaxis(tmp, 0, 0))
        else:
            dep_p = []
        return list(np.moveaxis(rgb_p, 0, 0)), dep_p
